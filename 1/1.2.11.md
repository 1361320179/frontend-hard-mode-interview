# 壹.2.11 位操作符与进制转换

为什么单独讲“位操作符”呢？因为我发现日常工作中，前端工程师朋友们经常使用**算术操作符、一元操作符、关系操作符、相等操作符**，就是很少有用到**位操作符**（\|，&，~，^，&lt;&lt;，&gt;&gt;）。但其实位操作符用好了又特别省事，一般的老手都会用它来实现一些特定功能，因此也会被经常问到来侧面考察一个前端工程师是否老到。所以，这里单独用一篇文章来系统性讲解位操作符。

## 基础讲解

### 按位与（&）

两个操作数中相对应的位都是1时，这位为1，否则都为零

```javascript
var a=3//011
var b=7//111
console.log(a&b)// 输出3 => 011
```

### 按位或（\|）

如果两个数对应的有一个为1时，这位就为1

```javascript
var a=3//011
var b=7//111
console.log(a|b)// 输出7 => 111
```

### 按位异或（^）

两个数对应位不同，这位才为1，否则为0

```javascript
var a=3//011
var b=7//111
console.log(a^b)// 输出4 => 100
```

### 按位非\(~\)

一元操作符。将操作数所有位取反。而根据js中带符号的整数的表示方法，对一个值使用~运算符相当于它的相反数减1。

```javascript
var b=-7
console.log(~b)//输出6
```

### 左移（&lt;&lt;）

将第一个操作数进行左移，移动的位数为第二个操作数\(0~31之间的一个整数\)，新的位由0补齐。

```javascript
var a=3
var b=7//000111
console.log(b<<a)//111000 => 输出56
```

### 有符号右移（&gt;&gt;）

将第一个操作数进行右移，移动的位数为第二个操作数\(0~31之间的一个整数\)，右边的溢出位被忽略，填补在左边的位由原操作数符号决定，以便保持结果的符号与原操作数一致。如果第一个操作数是正数，移位后用0填补最高位；如果为负，用1填补最高位。

```javascript
var a=2
var b=-7//1 111111001  
console.log(b>>a)//1 11111110 => -2  
```

### 无符号右移

同样右移，最高位补0，忽略符号位

```javascript
var a=4
var b=-1// 1 11111111
console.log(b>>>a)//0 0000 1111 1111 1111 1111 1111 1111 1111 => 输出268435455
```

## 进制转换

位操作涉及与二进制的转换，这里顺带把JavaScript的进制转换也讲一下。

### **1.十进制转其他**

十进制转其他相对简单，直接使用 toString\(\) 方法。

```javascript
//十进制转其他  
var x=110;  
alert(x);  
alert(x.toString(2));//转二进制
alert(x.toString(8));//转八进制
alert(x.toString(16));//转十六进制
```

### **2.其他转十进制**

其他进制转十进制也比较简单，使用parseInt，传递第二个参数代表当前数字的进制。

```javascript
//其他转十进制  
var x='110';  
alert(parseInt(x,2)); //二进制转十进制
alert(parseInt(x,8)); //八进制转十进制
alert(parseInt(x,16));//十六进制转十进制
```

### **3.其他进制转其他进制**

这里需要转换两次，首先使用parseInt转换到十进制，然后使用toString转换到目标进制。

```javascript
//其他转其他  
//先用parseInt转成十进制再用toString转到目标进制  
alert(String.fromCharCode(parseInt(141,8)))  
alert(parseInt('ff',16).toString(2));   
```

另外，可以参考这篇文章，[用笔和纸手算二进制与十进制转换](https://www.cnblogs.com/web-record/p/11132861.html)。

## 面试题

### 华为面试题：判断两个IP是否在同一子网

> 子网掩码是用来判断任意两台计算机的IP地址是否属于同一子网络的根据。  
> 子网掩码与IP地址结构相同，是32位二进制数，其中网络号部分全为“1”和主机号部分全为“0”。利用子网掩码可以判断两台主机是否中同一子网中。若两台主机的IP地址分别与它们的子网掩码相“与”后的结果相同，则说明这两台主机在同一子网中。
>
> #### 示例：
>
> **I P 地址　 192.168.0.1  
> 子网掩码　 255.255.255.0**
>
> 转化为二进制进行运算：
>
> I P 地址　  11010000.10101000.00000000.00000001  
> 子网掩码　11111111.11111111.11111111.00000000
>
> AND运算    11000000.10101000.00000000.00000000
>
> 转化为十进制后为： 192.168.0.0
>
> **I P 地址　 192.168.0.254  
> 子网掩码　 255.255.255.0**
>
> 转化为二进制进行运算：
>
> I P 地址　  11010000.10101000.00000000.11111110  
> 子网掩码　11111111.11111111.11111111.00000000
>
> AND运算    ****11000000.10101000.00000000.00000000
>
> 转化为十进制后为： 192.168.0.0
>
> 通过以上对两台计算机IP地址与子网掩码的AND运算后，我们可以看到它运算结果是一样的。均为192.168.0.0，所以这二台计算机可视为是同一子网络。

```javascript
//todo
```

